import LuatPlayground from '@site/src/components/LuatPlayground';

# Components

Components are the building blocks of LUAT applications. They encapsulate reusable UI elements and can accept props and render children.

## Basic Components

### Creating a Component

A component is simply a `.luat` file that exports a `render` function:

```html
<!-- Button.luat -->
<script>
    local variant = props.variant or "primary"
    local size = props.size or "medium"
    local classes = "btn btn-" .. variant .. " btn-" .. size
</script>

<button class={classes} type={props.type or "button"}>
    {@render props.children?.()}
</button>
```

### Using Components

Import components in the script block and use them like HTML elements:

```html
<!-- Page.luat -->
<script>
    local Button = require("components/Button")
</script>

<div class="page">
    <Button variant="primary" size="large">
        Click me!
    </Button>

    <Button variant="secondary">
        Cancel
    </Button>
</div>
```

**Try it live** - Click the tabs to see both files:

<LuatPlayground
  files={[
    {
      name: 'main.luat',
      code: `<script>
local Alert = require("Alert")
</script>

<div class="space-y-4">
    <Alert type="success">
        Your changes have been saved!
    </Alert>

    <Alert type="warning">
        Please review before continuing.
    </Alert>

    <Alert type="error">
        Something went wrong.
    </Alert>
</div>`
    },
    {
      name: 'Alert.luat',
      code: `<script>
local variant = props.type or "info"

local colors = {
    info = "bg-blue-100 border-blue-500 text-blue-800",
    success = "bg-green-100 border-green-500 text-green-800",
    warning = "bg-yellow-100 border-yellow-500 text-yellow-800",
    error = "bg-red-100 border-red-500 text-red-800"
}

local classes = colors[variant] or colors.info
</script>

<div class={"p-4 rounded-lg border-l-4 " .. classes}>
    {@render props.children?.()}
</div>`
    }
  ]}
  height={350}
/>

## Props

### Passing Props

Props are passed as attributes on the component tag:

```html
<script>
    local Card = require("components/Card")
</script>

<Card 
    title="User Profile" 
    subtitle="Manage your account"
    image="/avatar.jpg"
    isActive={true}
/>
```

### Spreading Props

You can use the spread operator (`...`) to pass all properties from a table to a component:

```html
<script>
    local Card = require("components/Card")
    local cardProps = {
        title = "User Profile",
        subtitle = "Manage your account",
        image = "/avatar.jpg",
        isActive = true
    }
</script>

<Card {...cardProps} />
```

This is particularly useful when:
- Forwarding props from a parent component
- Applying common properties to multiple components
- Building reusable component configurations

You can combine multiple spreads and override specific properties:

```html
<script>
    local baseProps = { size = "medium", variant = "default" }
    local themeProps = { variant = "primary", outlined = true }
</script>

<!-- Later spreads override earlier ones, and direct props override all spreads -->
<Button {...baseProps} {...themeProps} size="large" />
```

See [Template Syntax: Props Spread Operator](/docs/templating/syntax#props-spread-operator) for more details.

### Accessing Props

Inside the component, access props via the global `props` table:

```html
<!-- Card.luat -->
<script>
    local title = props.title
    local subtitle = props.subtitle or ""
    local image = props.image
    local isActive = props.isActive or false
</script>

<div class="card {isActive and 'active' or ''}">
    {#if image}
        <img src={image} alt={title} class="card-image">
    {/if}
    
    <div class="card-content">
        <h3 class="card-title">{title}</h3>
        {#if subtitle}
            <p class="card-subtitle">{subtitle}</p>
        {/if}
    </div>
</div>
```

### Default Props

Handle missing props with default values:

```html
<script>
    local variant = props.variant or "default"
    local size = props.size or "medium"
    local disabled = props.disabled or false
    local children = props.children
</script>
```

## Children

### Rendering Children

Use `{@render props.children?.()}` to render content passed between component tags:

```html
<!-- Modal.luat -->
<script>
    local title = props.title
    local isOpen = props.isOpen or false
</script>

{#if isOpen}
    <div class="modal-overlay">
        <div class="modal">
            <div class="modal-header">
                <h2>{title}</h2>
                <button class="modal-close">√ó</button>
            </div>
            <div class="modal-body">
                {@render props.children?.()}
            </div>
        </div>
    </div>
{/if}
```

### Using Components with Children

Pass content between the opening and closing tags:

```html
<script>
    local Modal = require("components/Modal")
</script>

<Modal title="Confirm Action" isOpen={showModal}>
    <p>Are you sure you want to delete this item?</p>
    <div class="modal-actions">
        <button>Cancel</button>
        <button class="danger">Delete</button>
    </div>
</Modal>
```

**Try it live** - A simple Alert component with children:

<LuatPlayground
  files={[
    {
      name: 'main.luat',
      code: `<script>
local Alert = require("Alert")
</script>

<div class="space-y-4">
    <Alert type="info">
        <strong>Tip:</strong> Use children to pass any content to components.
    </Alert>

    <Alert type="success">
        <p class="font-semibold">Order Confirmed!</p>
        <p class="text-sm mt-1">Your order #12345 has been placed successfully.</p>
    </Alert>

    <Alert type="warning">
        Your session will expire in <strong>5 minutes</strong>.
    </Alert>
</div>`
    },
    {
      name: 'Alert.luat',
      code: `<script>
local alertType = props.type or "info"

local styles = {
    info = "bg-blue-50 border-blue-500 text-blue-800",
    success = "bg-green-50 border-green-500 text-green-800",
    warning = "bg-yellow-50 border-yellow-500 text-yellow-800",
    error = "bg-red-50 border-red-500 text-red-800"
}

local icons = {
    info = "‚ÑπÔ∏è",
    success = "‚úì",
    warning = "‚ö†Ô∏è",
    error = "‚úï"
}

local classes = styles[alertType] or styles.info
local icon = icons[alertType] or icons.info
</script>

<div class={"p-4 rounded-lg border-l-4 flex gap-3 " .. classes}>
    <span class="text-lg">{icon}</span>
    <div>
        {@render props.children?.()}
    </div>
</div>`
    }
  ]}
  height={400}
/>

## Component Composition

### Nested Components

Components can use other components:

```html
<!-- UserCard.luat -->
<script>
    local Card = require("components/Card")
    local Button = require("components/Button")
    local Avatar = require("components/Avatar")
</script>

<Card title={props.user.name} subtitle={props.user.role}>
    <div class="user-card-content">
        <Avatar src={props.user.avatar} size="large" />
        
        <div class="user-info">
            <p>Email: {props.user.email}</p>
            <p>Joined: {props.user.createdAt}</p>
        </div>
        
        <div class="user-actions">
            <Button variant="primary">Edit</Button>
            <Button variant="secondary">View Profile</Button>
        </div>
    </div>
</Card>
```

### Layout Components

Create reusable layout components:

```html
<!-- Page.luat -->
<script>
    local AppBar = require("components/AppBar")
    local Footer = require("components/Footer")
    local currentNode = getContext("currentNode")
    local pageContext = getContext("pageContext")
</script>

<html>
<head>
    <title>{currentNode.properties.title}</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
    <div class="app">
        <AppBar />
        
        <main class="main-content">
            {@render props.children?.()}
        </main>
        
        <Footer />
    </div>
</body>
</html>
```

## Component Context

Context provides a way to pass data through the component tree without having to pass props manually at every level. This is useful for sharing data like themes, user information, or application state that many components need access to.

### Setting Context

Use `setContext(key, value)` to make data available to all child components:

```html
<script>
    -- Set context values that children can access
    setContext("theme", "dark")
    setContext("user", { name = "Alice", role = "admin" })
    setContext("config", { language = "en", currency = "USD" })
</script>

<ChildComponent />
```

### Getting Context

Use `getContext(key)` to retrieve context values set by parent components:

```html
<script>
    -- Access context from any parent component
    local theme = getContext("theme")
    local user = getContext("user")
    local config = getContext("config")
</script>

<div class={"app theme-" .. (theme or "light")}>
    Welcome, {user and user.name or "Guest"}!
</div>
```

### How Context Works

Context in Luat uses a **stack-based scoping system**:

1. Each component creates a new scope when it renders
2. `setContext()` writes to the current component's scope
3. `getContext()` searches from the current scope up through all parent scopes
4. When a component finishes rendering, its scope is removed

This means:
- Child components can access context set by any ancestor
- Sibling components cannot see each other's context
- Context values can be "overridden" by setting the same key in a child component

### Context Flow Example

Here's a practical example showing context flowing through three levels of components. The `App` sets theme and user context, `Dashboard` adds navigation context, and `UserCard` (three levels deep) accesses all of them:

<LuatPlayground
  files={[
    {
      name: 'main.luat',
      code: `<script>
local Dashboard = require("Dashboard")

-- App-level context: available to ALL descendants
setContext("theme", {
    mode = "dark",
    primary = "blue",
    accent = "purple"
})

setContext("user", {
    name = "Alice Chen",
    email = "alice@example.com",
    role = "Admin",
    avatar = "üë©‚Äçüíª"
})

setContext("app", {
    name = "My Application",
    version = "1.0.0"
})
</script>

<div class="min-h-[400px] bg-gray-900 text-white p-4 rounded-xl">
    <header class="border-b border-gray-700 pb-3 mb-4">
        <h1 class="text-xl font-bold">Context Demo App</h1>
        <p class="text-gray-400 text-sm">Context flows through 3 levels of components</p>
    </header>

    <!-- Dashboard is level 2, UserCard inside is level 3 -->
    <Dashboard />
</div>`
    },
    {
      name: 'Dashboard.luat',
      code: `<script>
local UserCard = require("UserCard")
local Sidebar = require("Sidebar")

-- Access parent context
local theme = getContext("theme")
local app = getContext("app")

-- Add MORE context for children (extends, doesn't replace parent context)
setContext("navigation", {
    currentPage = "dashboard",
    breadcrumbs = { "Home", "Dashboard" }
})
</script>

<div class="grid grid-cols-3 gap-4">
    <!-- Sidebar accesses theme + navigation context -->
    <Sidebar />

    <!-- Main content area -->
    <div class="col-span-2 space-y-4">
        <div class="bg-gray-800 rounded-lg p-4">
            <h2 class="font-semibold text-lg mb-2">Dashboard</h2>
            <p class="text-gray-400 text-sm">Theme: {theme.mode} mode with {theme.primary} accent</p>
        </div>

        <!-- UserCard is 3 levels deep, can access ALL context -->
        <UserCard />
    </div>
</div>`
    },
    {
      name: 'UserCard.luat',
      code: `<script>
-- Access context from grandparent (App) - 2 levels up!
local user = getContext("user")
local theme = getContext("theme")
local app = getContext("app")

-- Access context from parent (Dashboard) - 1 level up
local nav = getContext("navigation")

-- Build theme-aware classes
local cardBg = theme.mode == "dark" and "bg-gray-800" or "bg-white"
local textColor = theme.mode == "dark" and "text-white" or "text-gray-900"
</script>

<div class={cardBg .. " rounded-lg p-4 border border-gray-700"}>
    <div class="flex items-center gap-3 mb-3">
        <span class="text-3xl">{user.avatar}</span>
        <div>
            <h3 class={"font-bold " .. textColor}>{user.name}</h3>
            <p class="text-gray-400 text-sm">{user.role}</p>
        </div>
    </div>

    <div class="text-sm space-y-1 text-gray-400">
        <p>üìß {user.email}</p>
        <p>üìç Page: {nav.currentPage}</p>
        <p>üè∑Ô∏è App: {app.name} v{app.version}</p>
    </div>

    <div class="mt-3 pt-3 border-t border-gray-700">
        <p class="text-xs text-gray-500">
            This component is 3 levels deep but accesses context from all ancestors
        </p>
    </div>
</div>`
    },
    {
      name: 'Sidebar.luat',
      code: `<script>
local theme = getContext("theme")
local nav = getContext("navigation")
local user = getContext("user")

local items = {
    { icon = "üè†", label = "Home", active = false },
    { icon = "üìä", label = "Dashboard", active = true },
    { icon = "‚öôÔ∏è", label = "Settings", active = false },
}
</script>

<aside class="bg-gray-800 rounded-lg p-3">
    <div class="text-xs text-gray-500 mb-2 px-2">
        NAVIGATION
    </div>
    <nav class="space-y-1">
        {#each items as item}
            <a href="#" class={"flex items-center gap-2 px-2 py-1.5 rounded text-sm " ..
                (item.active and "bg-" .. theme.primary .. "-600 text-white" or "text-gray-400 hover:text-white")}>
                <span>{item.icon}</span>
                <span>{item.label}</span>
            </a>
        {/each}
    </nav>
    <div class="mt-4 pt-3 border-t border-gray-700 text-xs text-gray-500 px-2">
        Logged in as {user.name}
    </div>
</aside>`
    }
  ]}
  height={580}
/>

### Context vs Props

Use **props** when:
- Data is specific to one component
- Parent needs to customize child behavior
- You want explicit data flow

Use **context** when:
- Many components at different levels need the same data
- Passing props through intermediate components is cumbersome ("prop drilling")
- Data is "global" within a subtree (theme, user, locale)

```html
<!-- Props: explicit, local -->
<Button variant="primary" size="large">Click</Button>

<!-- Context: implicit, shared -->
<script>
    setContext("theme", { variant = "primary", size = "large" })
</script>
<ThemedButton>Click</ThemedButton>  <!-- reads theme from context -->
```

### Framework-Provided Context

When using Luat with a framework like Wunderframe, certain context values are automatically available:

- `pageContext` - Page-level data and configuration
- `currentNode` - Current content node data
- `currentTheme` - Active theme settings

```html
<script>
    local pageContext = getContext("pageContext")
    local currentNode = getContext("currentNode")
</script>

<div data-theme={pageContext.currentTheme}>
    <h1>{currentNode.properties.title}</h1>
</div>
```

### Page Context API

While `setContext`/`getContext` use a scoped stack (values are lost when the component finishes rendering), **page context** persists for the entire request. This is ideal for page-level metadata like titles and descriptions.

#### `setPageContext(key, value)`

Sets a value in the page context that persists across the entire request:

```html
<script>
    -- Set the page title (used by app.html and HX-Title header)
    setPageContext("view_title", props.post.title .. " - My Blog")
</script>
```

#### `getPageContext(key)`

Retrieves a value from the page context:

```html
<script>
    local title = getPageContext("view_title")
</script>
```

#### Usage in Loaders

Page context can also be set from `+page.server.lua` loaders:

```lua
-- +page.server.lua
function load(ctx)
    local post = db.get_post(ctx.params.slug)

    -- Set page title for HTMX boosted navigation
    ctx.setPageContext("view_title", post.title)

    return { post = post }
end
```

#### Page Context vs Regular Context

| Feature | `setContext` | `setPageContext` |
|---------|-------------|------------------|
| **Scope** | Component subtree | Entire request |
| **Lifetime** | Until component finishes | Until response is sent |
| **Use case** | Sharing data with children | Page metadata (title, description) |
| **HTMX support** | No | Yes (`HX-Title` header) |

#### Special Keys

- `view_title` - Sets the page title. Used in `app.html` via `%luat.title%` and sent as `HX-Title` header for HTMX boosted navigation.

:::tip[Enable HX-Title Support]
To update the browser title during HTMX navigation, install the [@maravilla-labs/htmx-ext-title](https://www.npmjs.com/package/@maravilla-labs/htmx-ext-title) extension and add `hx-ext="title"` to your `<body>` tag. See [HTMX Patterns - Title Extension](/docs/advanced/htmx-patterns#title-extension) for setup details.
:::

```html
<!-- In +page.luat -->
<script>
    setPageContext("view_title", "About Us - My Site")
</script>

<h1>About Us</h1>
<p>Welcome to our company...</p>
```

## Component Types

### Module Exports

Components can export metadata using module scripts:

```html
<!-- Hero.luat -->
<script module>
    local type = "content:hero"
    exports.type = type
</script>

<script>
    local title = props.title
    local subtitle = props.subtitle
    local image = props.image
</script>

<div class="hero" style="background-image: url('{image}')">
    <div class="hero-content">
        <h1>{title}</h1>
        <p>{subtitle}</p>
    </div>
</div>
```

## Advanced Patterns

### Conditional Component Rendering

```html
<script>
    local Button = require("components/Button")
    local Link = require("components/Link")
    
    local ComponentToRender = props.href and Link or Button
</script>

<ComponentToRender href={props.href} onClick={props.onClick}>
    {props.label}
</ComponentToRender>
```

### Dynamic Block Rendering

A powerful pattern for CMS-style content is rendering different components based on block types. Here's how to render a blog post with various content blocks:

<LuatPlayground
  files={[
    {
      name: 'main.luat',
      code: `<script>
local TextBlock = require("TextBlock")
local ImageBlock = require("ImageBlock")
local QuoteBlock = require("QuoteBlock")

-- Blog post data (typically from a CMS or API)
local post = {
    title = "Getting Started with LUAT",
    author = "Alice Johnson",
    blocks = {
        { type = "text", content = "LUAT brings component-based architecture to server-side rendering. Let's explore how it works." },
        { type = "image", src = "https://picsum.photos/600/200", alt = "LUAT Architecture", caption = "Component-based architecture diagram" },
        { type = "quote", text = "The best code is no code at all.", author = "Jeff Atwood" },
        { type = "text", content = "With LUAT, you can build fast, secure, and maintainable web applications using familiar patterns." }
    }
}

-- Map block types to components
local blockComponents = {
    text = TextBlock,
    image = ImageBlock,
    quote = QuoteBlock
}
</script>

<article class="max-w-2xl mx-auto">
    <header class="mb-6">
        <h1 class="text-2xl font-bold text-gray-900 dark:text-gray-100">{post.title}</h1>
        <p class="text-gray-500 dark:text-gray-400">By {post.author}</p>
    </header>

    <div class="space-y-6">
        {#each post.blocks as block}
            {@local BlockComponent = blockComponents[block.type]}
            {#if BlockComponent}
                <BlockComponent {...block} />
            {:else}
                <div class="text-red-500">Unknown block type: {block.type}</div>
            {/if}
        {/each}
    </div>
</article>`
    },
    {
      name: 'TextBlock.luat',
      code: `<p class="text-gray-700 dark:text-gray-200 leading-relaxed">
    {props.content}
</p>`
    },
    {
      name: 'ImageBlock.luat',
      code: `<figure class="my-4">
    <img src={props.src} alt={props.alt} class="w-full rounded-lg shadow">
    {#if props.caption}
        <figcaption class="text-sm text-gray-500 dark:text-gray-400 mt-2 text-center">
            {props.caption}
        </figcaption>
    {/if}
</figure>`
    },
    {
      name: 'QuoteBlock.luat',
      code: `<blockquote class="border-l-4 border-blue-500 pl-4 py-2 bg-blue-50 dark:bg-blue-900 rounded-r-lg">
    <p class="text-gray-700 dark:text-gray-200 italic">"{props.text}"</p>
    {#if props.author}
        <cite class="text-sm text-gray-500 dark:text-gray-400 mt-1 block">‚Äî {props.author}</cite>
    {/if}
</blockquote>`
    }
  ]}
  height={550}
/>

This pattern is useful for:
- **CMS content** - Render different block types (text, images, videos, embeds)
- **Page builders** - Dynamic layouts with configurable sections
- **Form builders** - Different input types based on field configuration

### Component Factories

Create reusable HTML generators using factory functions. These return HTML strings that are rendered with `{@html}`:

```html
<script>
    local function createIcon(name)
        return function(iconProps)
            return string.format('<i class="icon icon-%s %s"></i>',
                name, iconProps.class or "")
        end
    end

    local HomeIcon = createIcon("home")
    local UserIcon = createIcon("user")
</script>

<nav>
    <a href="/home">{@html HomeIcon({class = "nav-icon"})}</a>
    <a href="/profile">{@html UserIcon({class = "nav-icon"})}</a>
</nav>
```

> **Note:** This pattern uses string-based HTML generation, not true component rendering. The factory function returns an HTML string, and `{@html}` outputs it unescaped. For reusable UI elements with children support, use regular components instead.

<LuatPlayground
  code={`<script>
-- Factory function that creates icon renderers
local function createIcon(name, defaultClass)
    return function(iconProps)
        local classes = defaultClass or ""
        if iconProps and iconProps.class then
            classes = classes .. " " .. iconProps.class
        end
        return string.format('<span class="inline-flex items-center justify-center w-6 h-6 %s">%s</span>',
            classes, name)
    end
end

-- Create specific icon functions
local HomeIcon = createIcon("üè†", "text-blue-500")
local UserIcon = createIcon("üë§", "text-green-500")
local SettingsIcon = createIcon("‚öôÔ∏è", "text-gray-500 dark:text-gray-400")
</script>

<nav class="flex gap-4 p-4 bg-gray-100 dark:bg-gray-700 rounded-lg">
    <a href="/home" class="flex items-center gap-2 text-gray-700 dark:text-gray-200 hover:text-blue-600">
        {@html HomeIcon()}
        <span>Home</span>
    </a>
    <a href="/profile" class="flex items-center gap-2 text-gray-700 dark:text-gray-200 hover:text-green-600">
        {@html UserIcon({class = "text-lg"})}
        <span>Profile</span>
    </a>
    <a href="/settings" class="flex items-center gap-2 text-gray-700 dark:text-gray-200 hover:text-gray-600 dark:hover:text-gray-100">
        {@html SettingsIcon({class = "animate-spin"})}
        <span>Settings</span>
    </a>
</nav>`}
  height={350}
/>

### Multiple Content Sections

Components can accept multiple render functions as props to create flexible layouts with header, body, and footer sections:

```html
<!-- Card.luat -->
<script>
    local title = props.title
</script>

<div class="card">
    {#if title}
        <div class="card-header">
            <h2>{title}</h2>
        </div>
    {/if}
    <div class="card-body">
        {@render props.children?.()}
    </div>
    {#if props.footer}
        <div class="card-footer">
            {@render props.footer()}
        </div>
    {/if}
</div>
```

Usage with title prop and footer render function:

```html
<script>
    local Card = require("components/Card")
</script>

<Card title="User Profile" footer={function(__write)
    __write("<button>Save</button>")
end}>
    <p>This is the main card content.</p>
</Card>
```

<LuatPlayground
  files={[
    {
      name: 'main.luat',
      code: `<script>
local Panel = require("Panel")
</script>

<div class="space-y-4">
    <Panel title="Welcome">
        <p>A simple panel with title and content.</p>
    </Panel>

    <Panel title="User Profile">
        <p><strong>Name:</strong> Alice Johnson</p>
        <p><strong>Email:</strong> alice@example.com</p>
    </Panel>
</div>`
    },
    {
      name: 'Panel.luat',
      code: `<script>
local title = props.title
</script>

<div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg overflow-hidden border dark:border-gray-700">
    <div class="bg-gradient-to-r from-blue-500 to-blue-600 px-4 py-3">
        <h2 class="text-lg font-bold text-white">{title}</h2>
    </div>
    <div class="p-4 text-gray-700 dark:text-gray-200">
        {@render props.children?.()}
    </div>
</div>`
    }
  ]}
  height={380}
/>

## Best Practices

### 1. Keep components focused

Each component should have a single responsibility:

```html
<!-- Good: Focused button component -->
<!-- Button.luat -->
<button class="btn btn-{props.variant}" disabled={props.disabled}>
    {@render props.children?.()}
</button>
```

### 2. Use descriptive prop names

```html
<!-- Good -->
<UserCard 
    user={userData}
    showActions={true}
    onEdit={handleEdit}
/>

<!-- Avoid -->
<UserCard 
    data={userData}
    flag={true}
    callback={handleEdit}
/>
```

### 3. Provide sensible defaults

```html
<script>
    local variant = props.variant or "primary"
    local size = props.size or "medium"
    local disabled = props.disabled or false
</script>
```

### 4. Document complex components

```html
<!-- 
UserProfileCard.luat

Props:
- user (object): User data with name, email, avatar
- editable (boolean): Whether to show edit controls  
- onSave (function): Callback when profile is saved
- onCancel (function): Callback when editing is cancelled
-->
<script>
    local user = props.user
    local editable = props.editable or false
</script>
```
